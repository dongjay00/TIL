# Django

> django 1일차 강의



## Dynamic Web Application Program

- Dynamic Web

  - 우리가 서버에 요청을 보냈을 때, 그 요청이 서버에서 추가적으로 처리가 되어서 우리에게 다시 응답으로 넘어옴
  - 사용자 요청에 따라 응답이 다르게 옴

  

- Static Web

  - 서버에 준비된 데이터는 그대로
  - 우리가 서버에 요청을 보내면 같은 데이터(같은 화면, 준비된 자료)를 계속 받게 된다
  - **미리 저장된 정적파일(HTML, CSS, JS)을 제공**
  - ex) github pages



## Django what? why? how?

### Django what

> Python web framework
>
> 파이썬으로 작성된 오픈소스 웹 어플리케이션 프레임워크

- 파이썬 기반 웹 프레임워크
  - **웹 페이지를 개발하는 과정에서 겪는 어려움을 줄이는 것이 주 목적**
  - 개인 카페 직접 창업 vs **프렌차이즈 카페 창업**
  - 기본적인 구조나 필요한 코드는 **알아서 제공**
  - 우리는 좋은 웹 서비스 만드는 것에 집중할 수 있다.



### Django why

> Spotify, Instagram, Dropbox, Delivery Hero 등이 Django를 이용해 만든 앱

- 개발자 커뮤니티가 잘 활성화 되어있다.
- 웹의 프로토콜 : 요청(request) <-> 응답(response)
- django는 **서버**를 담당(백엔드)



### Django how

> **모델-뷰-컨트롤러 모델 패턴**(MVC)

- 소프트웨어 디자인 패턴

  - django는 살짝 다르다(MTV)

    |    MVC 패턴    | django(MTV)  |
    | :------------: | :----------: |
    |   **M**odel    |  **M**odel   |
    |    **V**iew    | **T**emplate |
    | **C**ontroller |   **V**iew   |

  - Model : 데이터 관리

  - Template : 인터페이스(화면)

  - View : 중간 관리(상호 동작) -> controller 역할



- django 흐름도

  ![image-20200929224908249](01.%20Template,%20View%20%EA%B8%B0%EC%B4%88.assets/image-20200929224908249.png)

  1. 요청
  2. urls에서 요청 처리
  3. 거기에 맞는 view(함수)에서 동작 처리
     - 만약 요청이 웹페이지 문서라면, template에서 데이터 가져옴
     - 모델이 낀다면, 사용자가 요청을 보냈을 때 모델에서 데이터를 바꿈
       - 이후 view가 template과 잘 합쳐서 응답을 준다
  4. 응답



## Django start

```bash
$ pip install django
```



```bash
$ django-admin startproject first_project
```

- 프로젝트 만들기
  - 프로젝트명에 `-` (하이푼), python & django에서 쓰는 기본 이름들 금지 

- `cd first_project/`
  - manage.py를 사용하기 위해 폴더를 한단계 더 안쪽으로 이동



```bash
$ python manage.py runserver
```

- 서버를 연다
- http 주소를 준다



## project 내부 파일들

- `__init__.py` : 패키지를 모듈화 시켜주는 파일(`.`으로 접근 가능하게 만든다)
- `asgi.py` : 비동기 웹 서버에 배포할 때 쓰임 (django 3 이상에서만 존재)
- **`settings.py`** : django project의 모든 세팅을 담당
- **`urls.py`** : 요청이 장고 서버로 들어왔을 때 가장 먼저 만나는 파일
- `wsgi.py` : `asgi.py`와 궁극적인 목적은 같음. 일반 웹 서버에 배포할 때 사용.
  - final project할 때 사용할 것임



## App 생성

```bash
$ python manage.py startapp articles
```

- 앱의 이름은 **복수형**으로 만들 것



## App 내부 파일들

- `__init__.py` : 위에 적힌 내용과 동일
- `migrations` : model에 관련된 내용 (나중에 진행)
- `admin.py` : 관리자 전용 커스텀 페이지
- `apps.py` : 앱에 대한 정보 (작성하지 않음)
- `models.py` : MTV에서 M을 담당 (나중에 진행)
- `tests.py` : 배포 전 테스트를 위해 테스트 코드를 작성하는 곳
- `views.py` : 가장 핵심 파일. MTV에서 V를 담당



## App 등록

> - settings.py 내부에 작성
>
> - 반드시 App 생성을 먼저 하고, App 등록을 해야 한다

```python
INSTALLED_APPS = [
    # 1. local apps
    'articles',
    # 2. 3rd party apps
    # 3. django apps
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```

- django 컨벤션 
  - 안 지킨다고 오류가 나진 않지만 지켜줄 것
  - 앱 등록 시 위쪽부터 작성
  - 마지막에 `,` 빼먹지 말 것



## Setting 변경하기

- `en-us` -> `ko-kr`
  - 기본 언어가 한국어로 설정



## Url 생성

> urls.py

```python
from django.contrib import admin
from django.urls import path
from articles import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('index/',),
]
```

- url 쓸때 항상 `/`를 뒤에 붙일 것
- 이 url이 어떤 view함수를 호출할 것인가를 명시해야 함
  - articles 패키지 내부의 view 함수 import
- 마지막에 `,` 빼먹지 말 것



아직 view 함수 작성을 안했으니, 먼저 작성합시다



## views.py 작성

```python
from django.shortcuts import render

# Create your views here.
def index(request):
    pass
```

- 첫번째 인자로 반드시 request를 받는다.

- pass 작성해놓고 일단 다시 url로 돌아가서 완성시켜 놓는다. (`views.index`)

  ```python
  from django.contrib import admin
  from django.urls import path
  from articles import views
  
  urlpatterns = [
      path('admin/', admin.site.urls),
      path('index/', views.index),
  ]
  ```

- 일반적으로 url과 함수 이름은 같은 걸로 쓴다(다르게 써도 상관 없음)



## templates 생성

- 앱 내부에 `templates` 폴더 생성 (반드시 이름이 templates여야 한다)

- `templates` 폴더 내부에 `index.html` 생성

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <h1>안녕하세요! 반갑습니다!!</h1>
  </body>
  </html>
  ```

- view가 이 html 문서를 return 해줘야 한다.

- `views.py`에 해당 내용 return 해준다.

  ```python
  from django.shortcuts import render
  
  # Create your views here.
  def index(request):
      return render(request, 'index.html')
  ```

  - render의 첫번째 인자는 무조건 request
  - templates/index.html 왜 이런식으로 안쓰나요?
    - django의 약속 중 하나인 templates 이름을 지켰기 때문에, django가 알아서 판단하여 처리해 줌



### 정리

1. 사용자가 `index/`라는 요청을 함 

2. urls.py의 path함수가 index/를 인식하고, 이에 해당하는 views.py의 index 함수를 호출
3. views.py의 index 함수가 index.html 문서를 잘 렌더링해서 가지고 온다
4. 사용자에게 응답 완료



## 코드 작성 순서

> 데이터의 흐름(url -> view -> template)과 일치

1. `urls.py`
2. `views.py`
3. `templates`



## 저녁 메뉴 추천

- 코드 상의 변경만 있을 땐 서버를 굳이 안꺼줘도 상관 없다. 계속 알아서 반영해 준다

  - 반면 파일이나 폴더를 새로 만드는 경우는 서버를 끈 후 다시 켜줘야 적용이 된다

  ```python
  urlpatterns = [
      path('admin/', admin.site.urls),
      path('index/', views.index),
      path('dinner/', views.dinner),
  ]
  ```

  

- django views.py의 함수 간에는 **두 줄 띄어쓰기**로 해주는 것이 컨벤션 (Pep 8)

- import할 때에도 컨벤션이 있다. (주석 참고)

  ```python
  # django imports style guide
  # 1. standard library
  import random
  # 2. 3rd party
  # 3. Django
  from django.shortcuts import render
  # 4. local django
  
  
  # Create your views here.
  def index(request):
      return render(request, 'index.html')
  
  
  def dinner(request):
      menus = ['족발', '햄버거', '치킨', '초밥']
      pick = random.choice(menus)
      return render(request, 'dinner.html', {'pick': pick,})
  ```

  - 왼쪽의 'pick'은 템플릿에서 사용할 이름(키)
  - 오른쪽의 pick은 dinner 함수 내에서 정의한 pick
  - 일부러 같게 맞춰둠 (다르게 만들면 헷갈림)
  - 마지막에 `,` 빼먹지 말 것

  

- django-html

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <h1>오늘 저녁은 {{ pick }} 입니다.</h1>
  </body>
  </html>
  ```

  - 템플릿 변수: {{ pick }} 이런 식으로 중괄호 두 개로 감싸줌



- 만약 template에 들어갈 변수가 많아진다면?

  - 따로 context라는 딕셔너리를 만들어서 적용

  ```python
  def dinner(request):
      menus = ['족발', '햄버거', '치킨', '초밥']
      pick = random.choice(menus)
      context = {
          'pick': pick,
      }
      return render(request, 'dinner.html', context)
  ```

  

## Variable routing

> - 127.0.0.1:8000/hello/`이름`
>
> - `이름`님 반갑습니다!

- url 하나만 가지고 `이름`은 변수화해서 쓸것임

  ```python
  urlpatterns = [
      path('hello/<str:name>/', views.hello),
  ]
  ```

  - `<type:변수명>` 이런 식으로 작성한다
  - ex) `<str:name>`



- view 함수에서 받아줄 인자가 하나 더 생겼다 (name)

  ```python
  def hello(request, name):
      context = {
          'name': name,
      }
      return render(request, 'hello.html', context)
  
  ```

  - **인자명은 url에서 적용한 변수명과 같아야 한다**
  - context 내부 오른쪽의 name이 바로 인자로 받아준 name이다



- html 파일에 키값 적용

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <h1>안녕하세요, {{ name }}</h1>
  </body>
  </html>
  ```



- **흐름을 잡는 것이 중요!!!**



## Django Template Language(DTL)

> Django template system에서 사용하는 built-in template system

- 조건, 반복, 치환, 필터, 변수 등의 기능을 제공
  - 그냥 html에선 사용 불가
- 프로그래밍적 로직이 아니라 프레젠테이션을 표현하기 위한 것
  - template의 역할을 넘어서지 말 것



### syntax

[장고 템플릿](https://docs.djangoproject.com/en/3.1/topics/templates/)

- 공식문서 내에서 검색하지 말고 구글에서 검색할 것
- 우측에 있는 목차로 흐름을 파악하고, 찾고 싶은거 클릭
- 링크 추가적으로 걸린 것도 잘 써먹자



- variable : `{{ }}`
- filter : `{{ variable|filter }}`
  - `length` : value의 길이를 return / str이나 list에서 사용 가능
- tags : `{% tag %}`
  - for, if, elif 등등 제공
  - 파이썬처럼 if, for를 사용할 수 있지만, 이것은 단순히 python code로 실행되는 것은 아니다



## DTL-practice

- url은 `_`말고 `-`을 쓰는 것을 더 권장

  ```python
  urlpatterns = [
      path('dtl-practice/', views.dtl_practice),
  ]
  ```

  - python 변수명은 `_`을 쓰니 주의



- view 함수 작성

  ```python
  def dtl_practice(request):
      menus = ['짜장면', '탕수육', '짬뽕']
      empty_list = []
      context = {
          'menus': menus,
          'empty_list': empty_list,
      }
      return render(request, 'dtl_practice.html', context)
  ```



- dtl_practice.html

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <h1>DTL for, if tags 연습</h1>
    <h2>1. for tag</h2>
    {% for menu in menus %}
      {{ menu }}
    {% endfor %}
    <hr>
    {% for menu in menus %}
      {{ forloop.counter }} : {{ menu }}
    {% endfor %}
    <hr>
    {% for x in empty_list %}
      {{ x }}
    {% empty %}
      <p>아무것도 없어요!!</p>
    {% endfor %}
    <hr>
    <h2>2. if tag</h2>
    {% if '짜장면' in menus %}
      <p>짜장면은 고추가루지</p>
    {% endif %}
    <hr>
    {% if empty_list|length > 10 %}
      <p>길이가 10보다 크네요.</p>
    {% else %}
      <p>길이가 10보다 작네요.</p>
    {% endif %}
  </body>
  </html>
  ```

  - for tag
    - menu들이 일렬로 출력
    - `forloop.counter` : 1부터 번호가 자동으로 붙음(넘버링)
    - `forloop.counter0` : 0부터 넘버링
  - empty tag
    - 비어있다면 `empty`에 적힌 부분이 출력
    - if tag로도 구현할 수 있지만, empty로 쓰는 것이 훨씬 짧고 깔끔함
  - if tag
    - and, or, not, is 모두 사용 가능
    - elif, else도 사용 가능
    - ==, !=, < 등 다 사용 가능
    - filter도 당연히 사용 가능



## 템플릿 시스템 설계 철학

- 장고는 템플릿 시스템이 **표현**을 제어하는 도구이자 표현에 관련된 로직일 뿐이라고 생각한다.
- 템플릿 시스템에서는 이러한 기본 목표를 넘어서는 기능을 지원해서는 안된다.



## form 태그를 통해 요청 보내기(검색창)

> - 메아리(내가 ssafy를 검색하면, 서버도 ssafy에 해당하는 응답을 준다)
> - 몇 개의 view함수가 이 로직에 필요한가? **2개**
>   1. form을 받을 페이지 함수
>   2. 결과를 보여줄 페이지 함수



### throw

- throw url 작성

  ```python
  urlpatterns = [
      path('throw/', views.throw),
  ]
  ```



- view 함수 작성

  ```python
  def throw(request):
      return render(request, 'throw.html')
  ```

  

- throw.html

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <h1>Throw 페이지</h1>
    <form action="/catch/" method="GET">
      <label for="name">데이터 입력 : </label>
      <input type="text" id="name" name="name">
      <input type="submit">
    </form>
  </body>
  </html>
  ```

  - form 태그

    - `action` : 어디로 요청을 보내줄 것인가 (우리는 catch로!)

      - 네이버 예시 

      - [https://search.naver.com/search.naver?sm=top_hty&fbm=1&ie=utf8&query=헤이즈](https://search.naver.com/search.naver?sm=top_hty&fbm=1&ie=utf8&query=헤이즈)

      - 물음표 전까지가 action에 해당

      - 물음표 이후는 쿼리스트링

        - query=헤이즈 가 key, value값으로 넘어간 것임

        - key는 `input` tag의 name값, value는 `input` tag의 value값

          ```html
          <input name="query">
          ```

  - input 태그

    - type : 형식
      - submit : form의 action을 행하기 위해 반드시 눌러줘야 함
      - text : 글을 입력할 수 있음
        - 입력해준 글은 value값
        - 그에 상응하는 key값인 name값을 input태그에 넣어줘야 함
    - id : label 태그의 for 속성과 연결 (이름을 같게 해줘야 함)

  - '김준호'라는 값을 넣고 제출하면 다음과 같은 url로 바뀐다

    - [http://127.0.0.1:8000/throw/?name=김준호](http://127.0.0.1:8000/throw/?name=김준호)



- throw의 역할은 form을 적을 수 있는 페이지를 보여줄 뿐
  - name의 값을 받아서 다시 새로운 페이지에 출력을 해줄 두번째 view 함수가 필요



### catch

> throw.html이라는 응답에서 form을 통해 다시 catch로 요청을 한 셈

- catch url 작성

  ```python
  urlpatterns = [
      path('catch/', views.catch),
  ]
  ```



- view 함수 작성

  ```python
  def catch(request):
      # throw에서 보낸 form 데이터를 받기
      print(request.GET)
      return render(request, 'catch.html')
  ```

  - `request.GET`(위에서 쓴 method가 GET 방식이니까) 안에, throw에서 보낸 form  데이터가 들어있다.

  - 그냥 고의로 'catch.html' 부분을 'catchdddssdaasd.html' 요런 식으로 없는 html 문서로 바꿔본다면? -> **TemplateDoesNotExist** 에러 발생

    ![image-20200930122924981](01.%20Template,%20View%20%EA%B8%B0%EC%B4%88.assets/image-20200930122924981.png)

    - 밑으로 스크롤 내리면 우리가 확인하고 싶었던 request information이 있다

      ![image-20200930123044574](01.%20Template,%20View%20%EA%B8%B0%EC%B4%88.assets/image-20200930123044574.png)

      - 어마어마하게 많은 정보들이 request 안에 들어있다.
      - request의 정보들은 key, value 형식으로 저장되어있다.

    - throw 페이지에서 '내가 보내는 데이터'라는 입력을 보내보자

      - 'catchdddssdaasd.html'는 없는 템플릿이므로 당연히 같은 오류가 뜰것이다.

      - 밑으로 스크롤 해보면 GET 부분에 아까 없던 key, value가 생긴 것을 확인할 수 있다.

        ![image-20200930123536414](01.%20Template,%20View%20%EA%B8%B0%EC%B4%88.assets/image-20200930123536414.png)

      - 이것을 request.GET으로 접근 할 수 있다

        - `{'name': '내가 보내는 데이터'}`

  - 확인을 위해 print(request.GET)을 해보았더니

    - `<QueryDict: {'name': ['내가 보내는 데이터']}>` 이렇게 출력 된다
    - QueryDict ? : django 내부적으로 사용하는 딕셔너리

  - 이제 딕셔너리의 value값에 접근해보자 (`get`)

    - 직접 key에 접근하는 것은, key가 없으면 오류 발생 (서버가 중단)
    - .get은 key가 없을때 None을 돌려주므로 얘를 쓰자

    ```python
    def catch(request):
        # throw에서 보낸 form 데이터(request.GET)를 받기
        # print(request.GET)
        message = request.GET.get('name')
        context = {
            'message': message,
        }
        return render(request, 'catch.html', context)
    ```

    

- catch.html

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <h1>Catch 페이지</h1>
    <h2>throw 에서 보낸 데이터는 {{ message }} 입니다.</h2>
  </body>
  </html>
  ```

  

### 정리

1. throw.html : form 태그 action을 이용해
2. /catch/로 요청 보냄
3. catch view 함수 : 데이터 처리
4. catch.html 을 통해 show 



## GET Method

> 데이터 단순 **조회**할 때 쓰는 방식
>
> 보여줘도 되는 것들!!

- form tag의 디폴트 method는 GET

  - 개발자 도구의 Network 탭에서 쿼리스트링으로 넘어간 GET 데이터를 확인할 수 있다.

  ![image-20200930132625292](01.%20Template,%20View%20%EA%B8%B0%EC%B4%88.assets/image-20200930132625292.png)

  

- 나중에 배울 POST 방식

  - 얘는 노출되어선 안되는 것들!! (ex) 로그인 정보)

  - GET은 쿼리스트링으로 넘어가지만, POST는 http body 쪽으로 넘어감
  - 데이터의 **변경**



## 마무리

1. python web framework
2. MTV 패턴
3. 독선적 vs 관용적 framework
   - 독선적 프레임워크 : 자유도 낮음. 가이드라인 충실.
   - 관용적 프레임워크 : 자유도 높음. 개발자가 손대야 할 것이 많음.
   - django? : 다소 독선적인 프레임워크 -> 높은 생산성!





# 오프라인 수업 내용

## URL 분리

> 각 app 폴더에 urls.py를 각각 작성함으로써 코드 유지보수에 긍정적인 구조로 변경



**두번째 app 생성 및 등록**

```bash
$ python manage.py startapp pages
```

```python
INSTALLED_APPS = [
    'articles',
    'pages',
    ...,
]
```



**프로젝트 urls.py**

```python
# firstapp/urls.py

from django.urls import path, include


urlpatterns = [
    path('admin/', admin.site.urls),
    path('articles/', include('articles.urls')),
    path('pages/', include('pages.urls')),
]
```



`include()`

- 다른 URLconf(app1/urls.py)들을 참조할 수 있도록 도와준다.
- Django가 함수 `include()`를 만나게 되면, URL의 그 시점까지 일치하는 부분을 잘라내고, 남은 문자열 부분을 후속 처리를 위해 include 된 URLconf로 전달한다.



---



## URL Name

> path() 함수의 name value를 작성해 `{% url %}` template tag로 호출



**url template tag**

> https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#url

- django 는 path() 함수에서 name 인수(optional) 를 정의해, `{% url %}` template tag 를 사용하여 URL 설정에 정의된 특정한 URL 경로들의 의존성을 제거할 수 있다.

  ```python
  # articles/urls.py
  
  urlpatterns = [
      path('index/', views.index, name='index'),
      path('dinner/', views.dinner, name='dinner'),
      path('hello/<str:name>/', views.hello, name='hello'),
      path('dtl-practice/', views.dtl_practice, name='dtl_practice'),
      path('throw/', views.throw, name='throw'),
      path('catch/', views.catch, name='catch'),
  ]
  ```

  ```django
  <!-- throw.html -->
  
  <body>
    <h1>Throw 페이지</h1>
    <form action="{% url 'catch' %}" method="GET">
      <label for="name">데이터 입력 : </label>
      <input type="text" id="name" name="name">
      <input type="submit">
    </form>
  </body>
  ```



---



## URL Namespace

- 예를 들어, articles app은 index 이라는 view를 가지고 있고, 동일한 프로젝트에 다른 app 에서도 index 이라는 view를 가지고 동일한 url name 을 사용할 수도 있다. 과연 Django가 `{% url 'index' %}` 처럼 사용할 때, 어떤 app 의 view 에서 URL을 생성할지 알 수 있을까?

  ```python
  # articles/urls.py
  
  app_name = 'articles'
  urlpatterns = [
      ...
  ]
  ```

  ```python
  # pages/urls.py
  
  app_name = 'pages'
  urlpatterns = [
  ]
  ```

  - urls.py 에 app_name 을 통해 app 의 이름공간을 설정한다.
  - 이제 기존 모든 url 은 다음과 같이 변경할 수 있다.

  ```django
  <!-- throw.html -->
  
  <form action="{% url 'articles:catch' %}" method="GET">
    ...
  </form>
  ```

  

---



## Django Namespace

> Namespace
>
> 이름공간 또는 네임스페이스(Namespace)는 객체를 구분할 수 있는 범위를 나타내는 말로 일반적으로 하나의 이름 공간에서는 하나의 이름이 단 하나의 객체만을 가리키게 된다.
>
> django에서는 서로 다른 app의 같은 이름을 가진 url name은 app_name을 설정해서 구분하고,
>
> templates, static 등 django는 정해진 경로 하나로 모아서 보기 때문에 중간에 폴더를 임의로 만들어 줌으로써 이름공간을 설정한다.



**파일트리 예시**

```
├── articles
│   ├── templates
│   │   └── articles
│   │       ├── catch.html
│   │       ├── dinner.html
│   │       ├── dtl_practice.html
│   │       ├── hello.html
│   │       ├── index.html
│   │       └── throw.html
```

```python
# articles/views.py 

return render(request, 'articles/index.html')
```



---



## Template Inheritance

> https://docs.djangoproject.com/ko/3.1/ref/templates/language/#template-inheritance



**템플릿 상속**

- 템플릿 상속을 사용하면 사이트의 모든 공통 요소를 포함하고, 하위 템플릿이 재정의(override) 할 수있는 블록(block)을 정의하는 기본 "스켈레톤" 템플릿을 만들 수 있다.

- 템플릿 상속은 기본적으로 코드의 재사용성에 초점을 맞춘다. 



**작성**

- `base.html` 파일을 `firstapp/templates/base.html` 에 생성 해보자.

- Django는 기본적으로 `app_name/templates` 를 바라보게 설정되어있다. (`APP_DIRS=True` 설정)

- 우리가 옮긴 위치는 `project폴더/templates` 이므로, Django는 현재 상태에서 해당 template 파일을 찾을 수 없다.

- 각 앱 내의 `templates` 폴더가 아닌 임의의 위치에 있는 template을 읽기 위해서는 Django에서 그 위치를 알려줘야 한다.

  ```python
  TEMPLATES = [
      {
          'BACKEND': 'django.template.backends.django.DjangoTemplates',
          'DIRS': [BASE_DIR / 'first_project' / 'templates'],
          ...,
  ]
  ```



**[참고] Path()** 

> os 마다 경로를 표기하는 `/` , `\` 로 다를 수 있음. (ex. WINDOWS) 
>
> 어떤 환경에서건 `/` 로 경로 표기(unix path)를 통일하기 위해 사용
>
> https://docs.python.org/ko/3/library/pathlib.html#module-pathlib



**템플릿 상속을 위한 기본 세팅**

- 프로젝트 폴더에서 `templates` 폴더 만든 후에 `base.html` 파일 생성

  ```django
  <!-- firstapp/templates/base.html -->
  
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="<https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css>" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <title>Document</title>
  </head>
  <body>
    <h1 class="text-center">Template Inheritance</h1>
    <hr>
    <div class="container">
      {% block content %}
      {% endblock %}
    </div>
    <script src="<https://code.jquery.com/jquery-3.5.1.slim.min.js>" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="<https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js>" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    <script src="<https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js>" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
  </body>
  </html>
  ```



**`block` tag**

- 하위 템플릿에서 재 지정(overriden)할 수있는 블록을 정의
- 하위 템플릿이 채울 수 있는 공간



**`extends` tag**

> https://docs.djangoproject.com/ko/3.1/ref/templates/builtins/#std:templatetag-extends

- 이(자식) 템플릿이 부모 템플릿을 확장한다는 것을 알림

- `{% extends '' %}` 는 반드시 문서의 최상단에 위치해야 한다.

  ```django
  {% extends 'base.html' %}
  
  {% block content %}
    <h1>안녕하세요! 반갑습니다!!</h1>
  {% endblock %}
  ```



**django 설계 철학 (Template)**

> https://docs.djangoproject.com/ko/3.1/misc/design-philosophies/#template-system

- 표현과 로직(view)을 분리

  - 우리는 템플릿 시스템이 `표현`을 제어하는 도구이자 표현에 관련된 로직일 뿐이라고 본다. 
  - 템플릿 시스템은 이러한 기본 목표를 넘어서는 기능을 지원하지 말아야 한다,

- 중복을 배제

  - 대다수의 동적 웹사이트는 공통 헤더, 푸터, 네이게이션 바 같은 사이트 공통 디자인을 갖는다. 

    Django 템플릿 시스템은 이러한 요소를 한 곳에 저장하기 쉽게 하여 중복 코드를 없애야 한다.

  - 이것이 `템플릿 상속`의 기초가 되는 철학